#!/bin/sh
#
# <%= @mysql_name %>	This shell script takes care of starting and stopping
#                       the MySQL subsystem (mysqld).
#
# chkconfig: - 64 36
# description:	MySQL database server.
# processname: mysqld
# config: <%= @etc_dir %>/my.cnf
# pidfile: <%= @pid_file %>
# socket_file: <%= @socket_file %>
### BEGIN INIT INFO
# Provides: <%= @mysql_name %>
# Required-Start: $local_fs $remote_fs $network $named $syslog $time
# Required-Stop: $local_fs $remote_fs $network $named $syslog $time
# Short-Description: start and stop MySQL server
# Description: MySQL database server
### END INIT INFO

# Source function library.
. /etc/rc.d/init.d/functions

# Source networking configuration.
. /etc/sysconfig/network


exec="<%= @base_dir %>/usr/bin/mysqld_safe"
prog="<%= @mysql_name %>"

# Set timeouts here so they can be overridden from <%= @base_dir %>/etc/sysconfig/mysqld
STARTTIMEOUT=120
STOPTIMEOUT=60

[ -e <%= @base_dir %>/etc/sysconfig/<%= @mysql_name %> ] && . <%= @base_dir %>/etc/sysconfig/<%= @mysql_name %>

lockfile=/var/lock/subsys/<%= @mysql_name %>


# extract value of a MySQL option from config files
# Usage: get_mysql_option SECTION VARNAME DEFAULT
# result is returned in $result
# We use my_print_defaults which prints all options from multiple files,
# with the more specific ones later; hence take the last match.
get_mysql_option(){
	  result=`<%= @base_dir %>/usr/bin/my_print_defaults "$1" | sed -n "s/^--$2=//p" | tail -n 1`
	  if [ -z "$result" ]; then
	      # not found, use default
	      result="$3"
	  fi
}

errlogfile=<%= @error_log %>

start(){
    [ -x $exec ] || exit 5
    # check to see if it's already running
    MYSQLDRUNNING=0
    if [ -f "<%= @pid_file %>" ]; then
        MYSQLPID=`cat "<%= @pid_file %>" 2>/dev/null`
	      if [ -n "$MYSQLPID" ] && [ -d "/proc/$MYSQLPID" ] ; then
	          MYSQLDRUNNING=1
	      fi
    fi
    RESPONSE=`<%= @base_dir %>/usr/bin/mysqladmin --socket="<%= @socket_file %>" --user=UNKNOWN_MYSQL_USER ping 2>&1`

    if [ $MYSQLDRUNNING = 1 ] && [ $? = 0 ]; then
	      # already running, do nothing
	      action $"Starting <%= @mysql_name %>: " /bin/true
	      ret=0
    elif [ $MYSQLDRUNNING = 1 ] && echo "$RESPONSE" | grep -q "Access denied for user"
    then
	      # already running, do nothing
	      action $"Starting <%= @mysql_name %>: " /bin/true
	      ret=0
    else
    	  # prepare for start
	      touch "<%= @error_log %>" 2>/dev/null
	      if [ $? -ne 0 ]; then
	          # failed to touch log file, probably insufficient permissions
	          action $"Starting <%= @mysql_name %>: " /bin/false
	          return 4
	      fi
	      chown <%= @run_user %>:<%= @run_user %> "<%= @error_log %>"
	      chmod 0640 "<%= @error_log %>"
	      [ -x /sbin/restorecon ] && /sbin/restorecon "<%= @error_log %>"

	      # Pass all the options determined above, to ensure consistent behavior.
	      # In many cases mysqld_safe would arrive at the same conclusions anyway
	      # but we need to be sure.  (An exception is that we don't force the
	      # log-error setting, since this script doesn't really depend on that,
	      # and some users might prefer to configure logging to syslog.)
	      # Note: set --basedir to prevent probes that might trigger SELinux
	      # alarms, per bug #547485
	      if [ -S "<%= @socket_file %>" ] ; then
		        echo "Another MySQL daemon already running with the same unix socket."
		        action $"Starting <%= @mysql_name %>: " /bin/false
		        return 1
	      fi

	      $exec --defaults-file="<%= @etc_dir %>/my.cnf" >/dev/null 2>&1 &
	      safe_pid=$!
	      # Spin for a maximum of N seconds waiting for the server to come up;
	      # exit the loop immediately if mysqld_safe process disappears.
	      # Rather than assuming we know a valid username, accept an "access
	      # denied" response as meaning the server is functioning.
	      ret=0
	      TIMEOUT="$STARTTIMEOUT"
	      while [ $TIMEOUT -gt 0 ]; do
	          RESPONSE=`<%= @base_dir %>/usr/bin/mysqladmin --socket="<%= @socket_file %>" --user=UNKNOWN_MYSQL_USER ping 2>&1`
	          mret=$?
	          if [ $mret -eq 0 ]; then
		            break
	          fi
	          # exit codes 1, 11 (EXIT_CANNOT_CONNECT_TO_SERVICE) are expected,
	          # anything else suggests a configuration error
	          if [ $mret -ne 1 -a $mret -ne 11 ]; then
		            echo "$RESPONSE"
		            echo "Cannot check for MySQL Daemon startup because of mysqladmin failure."
		            ret=1
		            break
	          fi
	          echo "$RESPONSE" | grep -q "Access denied for user" && break
	          if ! /bin/kill -0 $safe_pid 2>/dev/null; then
		            echo "MySQL Daemon failed to start."
		            ret=1
		            break
	          fi
	          sleep 1
	          let TIMEOUT=${TIMEOUT}-1
	      done
	      if [ $TIMEOUT -eq 0 ]; then
	          echo "Timeout error occurred trying to start MySQL Daemon."
	          ret=1
	      fi
	      if [ $ret -eq 0 ]; then
	          action $"Starting <%= @mysql_name %>: " /bin/true
	          chmod o+r <%= @pid_file %> >/dev/null 2>&1
	          touch $lockfile
	      else
	          action $"Starting <%= @mysql_name %>: " /bin/false
	      fi
    fi
    return $ret
}

stop(){
	  if [ ! -f "<%= @pid_file %>" ]; then
	      # not running; per LSB standards this is "ok"
	      action $"Stopping <%= @mysql_name %>: " /bin/true
	      return 0
	  fi
	  MYSQLPID=`cat "<%= @pid_file %>" 2>/dev/null`
	  if [ -n "$MYSQLPID" ]; then
	      /bin/kill "$MYSQLPID" >/dev/null 2>&1
	      ret=$?
	      if [ $ret -eq 0 ]; then
		        TIMEOUT="$STOPTIMEOUT"
		        while [ $TIMEOUT -gt 0 ]; do
		            /bin/kill -0 "$MYSQLPID" >/dev/null 2>&1 || break
		            sleep 1
		            let TIMEOUT=${TIMEOUT}-1
		        done
		        if [ $TIMEOUT -eq 0 ]; then
		            echo "Timeout error occurred trying to stop MySQL Daemon."
		            ret=1
		            action $"Stopping <%= @mysql_name %>: " /bin/false
		        else
		            rm -f $lockfile
		            rm -f "<%= @socket_file %>"
		            action $"Stopping <%= @mysql_name %>: " /bin/true
		        fi
	      else
		        # kill command failed, probably insufficient permissions
		        action $"Stopping <%= @mysql_name %>: " /bin/false
		        ret=4
	      fi
	  else
	      # failed to read pidfile, probably insufficient permissions
	      action $"Stopping <%= @mysql_name %>: " /bin/false
	      ret=4
	  fi
	  return $ret
}

restart(){
    stop
    start
}

condrestart(){
    [ -e $lockfile ] && restart || :
}

# See how we were called.
case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    status)
        status -p <%= @pid_file %> <%= @mysql_name %>
        ;;
    restart)
        restart
        ;;
    condrestart|try-restart)
        condrestart
        ;;
    reload)
        exit 3
        ;;
    force-reload)
        restart
        ;;
    *)
        echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
        exit 2
esac

exit $?
